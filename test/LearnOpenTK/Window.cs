using LearnOpenTK.Common;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Windowing.Common;
using OpenTK.Windowing.GraphicsLibraryFramework;
using OpenTK.Windowing.Desktop;

namespace LearnOpenTK
{
    public class Window(GameWindowSettings gameWindowSettings, NativeWindowSettings nativeWindowSettings)
        : GameWindow(gameWindowSettings, nativeWindowSettings)
    {
        // Create the vertices for our triangle. These are listed in normalized device coordinates (NDC)
        // In NDC, (0, 0) is the center of the screen.
        // Negative X coordinates move to the left, positive X move to the right.
        // Negative Y coordinates move to the bottom, positive Y move to the top.
        // OpenGL only supports rendering in 3D, so to create a flat triangle, the Z coordinate will be kept as 0.
        private readonly float[] _vertices =
        {
            -0.5f, -0.5f, 0.0f, // Bottom-left vertex
             0.5f, -0.5f, 0.0f, // Bottom-right vertex
             0.0f,  0.5f, 0.0f  // Top vertex
        };

        // These are the handles to OpenGL objects. A handle is an integer representing where the object lives on the
        // graphics card. Consider them sort of like a pointer; we can't do anything with them directly, but we can
        // send them to OpenGL functions that need them.
        
        private int _vertexBufferObject;

        private int _vertexArrayObject;

        // This class is a wrapper around a shader, which helps us manage it.
        private Shader _shader;

        protected override void OnLoad()
        {
            base.OnLoad();

            // Это будет цвет фона после того, как мы очистим его, в нормализованных цветах.
            // нормализованные цвета отображаются в диапазоне от 0,0 до 1,0, причем 0,0 представляют черный, а 1,0 представляют
            // самое большое значение для этого канала.
            // Это глубокий зеленый.
            GL.ClearColor(0.2f, 0.3f, 0.3f, 1.0f);

            // Нам нужно отправить наши вершины на видеокарту, чтобы OpenGL могла их использовать.
            // Чтобы сделать это, нам нужно создать то, что называется буферным объектом вершины (VBO).
            // Они позволяют загружать кучу данных в буфер и отправлять буфер на видеокарту.
            // Это эффективно отправляет все вершины одновременно.

            // Во-первых, нам нужно создать буфер. Эта функция возвращает ручку, но на данный момент она пуста.
            _vertexBufferObject = GL.GenBuffer();

            // Теперь свяжите буфер. OpenGL использует одно глобальное состояние, поэтому после вызова,
            // Все будущие вызовы, которые изменяют VBO, будут применены к этому буферу, пока вместо этого не будет связан другой буфер.
            // Первый аргумент - это перечисление, указывающее, какой тип буфера мы связываем. VBO - это ArrayBuffer.
            // Существует несколько типов буферов, но сейчас необходимо только VBO.
            // Второй аргумент - это ручка для нашего буфера.
            GL.BindBuffer(BufferTarget.ArrayBuffer, _vertexBufferObject);

            // Наконец, загрузите вершины в буфер.
            // аргументы:
            // в какой буфер данных следует отправлять.
            // Сколько данных отправляется, в байтах. Как правило, вы можете установить это на длину вашего массива, умноженное на Sizeof (тип массива).
            // сами вершины.
            // Как будет использоваться буфер, чтобы OpenGL мог записать данные в правильное пространство памяти на графическом процессоре.
            // Существует три разных буферегинта для рисования:
            // staticdraw: этот буфер редко, если вообще когда-либо обновляется после того, как его первоначально загружали.
            // DynamicDraw: этот буфер будет часто меняться после первоначальной загрузки.
            // StreamDraw: этот буфер будет изменяться на каждом кадре.
            // написание в правильное пространство памяти важно! Как правило, вы захотите только staticdraw,
            // но обязательно используйте правильный для вашего варианта использования.
            GL.BufferData(BufferTarget.ArrayBuffer, _vertices.Length * sizeof(float), _vertices, BufferUsageHint.StaticDraw);

            // Одна примечательная вещь о буфере, в который мы только что загрузили данные, это то, что в нем нет никакой структуры. Это всего лишь куча поплавков (которые являются просто байтами).
            // Драйвер OpenGL не знает, как следует интерпретировать эти данные или как их следует разделить на вершины. Для этого OpenGL представляет идею 
            // вершина массива obejct (vao), который имеет работу по отслеживанию того, какие части или какие буферы соответствуют каким данным. В этом примере мы хотим настроить наш Vao, чтобы, чтобы 
            // Он говорит OpenGL, что мы хотим интерпретировать 12 байтов как 3 плавания, и разделить буфер на вершины, используя это.
            // Для этого мы генерируем и связываем вао (который выглядит обманчиво похоже на создание и связывание VBO, но они разные!).
            _vertexArrayObject = GL.GenVertexArray();
            GL.BindVertexArray(_vertexArrayObject);

            // Теперь нам нужно настроить, как вершина -шейдер будет интерпретировать данные VBO; Вы можете отправить практически любой данных C (и несколько не C.
            // Хотя это делает их невероятно гибкими, это означает, что мы должны указать, как эти данные будут сопоставлены с входными переменными шейдера.

            // Для этого мы используем функцию Gl.vertexattribpointer
            // Эта функция имеет две задания, чтобы рассказать OpenGL о формате данных, но также также связывать текущий буфер массива с VAO.
            // Это означает, что после этого вызова мы установили этот атрибут на исходные данные из текущего буфера массива и интерпретируем его так, как мы указали.
            // аргументы:
            // местоположение входной переменной в шейдере. Линия макета (местоположение = 0) в вершинном шейдере явно устанавливает ее на 0.
            // Сколько элементов будет отправлено в переменную. В этом случае 3 плавания для каждой вершины.
            // Тип данных установленных элементов, в данном случае.
            // должны ли данные быть преобразованы в нормализованные координаты устройства. В этом случае неверно, потому что это уже сделано.
            // шаг; Это сколько байтов находится между последним элементом одной вершины и первым элементом следующей. 3 * sizeof (float) в этом случае.
            // смещение; Это сколько байтов он должен пропустить, чтобы найти первый элемент первой вершины. 0 На сегодняшний день.
            // Шаг и смещение на данный момент как бы как -то задушенные, но когда мы попадаем в координаты текстуры, они будут показаны в более подробно.
            GL.VertexAttribPointer(0, 3, VertexAttribPointerType.Float, false, 3 * sizeof(float), 0);

            // Enable variable 0 in the shader.
            GL.EnableVertexAttribArray(0);

            // Мы сделали вершины, но как именно это должно быть преобразовано в пиксели для окончательного изображения?
            // Modern OpenGL делает этот трубопровод очень свободным, предоставляя нам большую свободу о том, как вершины превращаются в пиксели.
            // Недостаток в том, что нам действительно нужно еще две программы для этого! Они называются «шейдерами».
            // Шейдеры - это крошечные программы, которые живут на графическом процессоре. OpenGL использует их для обработки конвейера вершины-пикселя.
            // Проверьте общий класс шейдеров, чтобы увидеть, как мы создаем наши шейдеры, а также более подробное объяснение того, как работают шейдеры.
            // shader.vert и shader.frag содержит фактический код шейдера.
            _shader = new Shader("Shaders/shader.vert", "Shaders/shader.frag");

            // теперь включим шейдер.
            // Точно так же, как VBO, это глобально, поэтому каждая функция, которая использует шейдер, будет изменять этот, пока вместо этого не будет связана новая.
            _shader.Use();

            // Настройка теперь завершена! Теперь мы переходим к функции OnRenderFrame, чтобы наконец нарисовать треугольник.
        }

        // Теперь, когда инициализация сделана, давайте создадим нашу петлю рендеринга.
        protected override void OnRenderFrame(FrameEventArgs e)
        {
            base.OnRenderFrame(e);

            // Это очищает изображение, используя то, что вы устанавливаете в качестве Gl.clearcolor ранее.
            // OpenGL предоставляет несколько различных типов данных, которые можно отображать.
            // Вы можете очистить несколько буферов, используя несколько битных флагов.
            // Однако мы только изменяем цвет, поэтому Colorbufferbit - все, что нам нужно очистить.
            GL.Clear(ClearBufferMask.ColorBufferBit);

            // Нарисовать объект в OpenGL, он, как правило, так же просто, как привязка вашего шейдера,
            // Установка формы шейдеров (не сделано здесь, будет показана в будущем учебном пособии)
            // связывание вао,
            // и затем вызов функции OpenGL для рендеринга.

            // связать шейдер
            _shader.Use();

            // связать вао
            GL.BindVertexArray(_vertexArrayObject);

            //, а затем назовите нашу функцию рисования.
            // Для этого урока мы будем использовать GL.Drawarrays, которая является очень простой функцией рендеринга.
            // аргументы:
            // примитивный тип; Какого рода геометрический примитив представляет вершины.
            // opengl используется для поддержки многих различных примитивных типов, но почти все из них все еще поддерживаются
            // какой -то вариант треугольника. Так как мы просто хотим одного треугольника, мы используем треугольники.
            // Запуск индекс; Это только начало данных, которые вы хотите нарисовать. 0 здесь.
            // Сколько вершин вы хотите нарисовать. 3 для треугольника.
            GL.DrawArrays(PrimitiveType.Triangles, 0, 3);

            // Opentk Windows-это то, что известно как «двойной буфер». По сути, окно управляет двумя буферами.
            // Один отображается, а другой в настоящее время отображается окном.
            // Это избегает разрыва экрана, визуальный артефакт, который может произойти, если буфер изменяется во время отображения.
            // После рисования вызовите эту функцию, чтобы поменять буферы. Если вы этого не сделаете, это не покажет то, что вы отображали.
            SwapBuffers();

            // И это все, что вам нужно сделать для рендеринга! Теперь вы должны увидеть желтый треугольник на черном экране.
        }

        protected override void OnUpdateFrame(FrameEventArgs e)
        {
            base.OnUpdateFrame(e);

            var input = KeyboardState;

            if (input.IsKeyDown(Keys.Escape))
            {
                Close();
            }
        }

        protected override void OnResize(ResizeEventArgs e)
        {
            base.OnResize(e);

            // When the window gets resized, we have to call GL.Viewport to resize OpenGL's viewport to match the new size.
            // If we don't, the NDC will no longer be correct.
            GL.Viewport(0, 0, Size.X, Size.Y);
        }
        // Теперь чистим.
        // Как правило, мы не должны очищать ресурсы OpenGL при выходе из приложения,
        // как это обрабатывается драйвером и операционной системой, когда приложение выходит.
        // 
        // Существуют причины удаления ресурсов OpenGL, но выход из приложения не является одним из них.
        // Это предусмотрено здесь как ссылка на то, как очистка ресурсов выполняется в OpenGL, но
        // не следует делать при выходе из приложения.
        //
        // Местами, где уместна очистка, будет: удалить текстуры, которые не являются
        // Дольше используется по какой -либо причине (например, загружается новая сцена, которая не использует текстуру).
        // Это освободит видео оперативной памяти (VRAM), который можно использовать для новых текстур.
        //
        // Предстоящие главы не будут иметь этого кода.
        protected override void OnUnload()
        {
            // Unbind all the resources by binding the targets to 0/null.
            GL.BindBuffer(BufferTarget.ArrayBuffer, 0);
            GL.BindVertexArray(0);
            GL.UseProgram(0);

            // Delete all the resources.
            GL.DeleteBuffer(_vertexBufferObject);
            GL.DeleteVertexArray(_vertexArrayObject);

            GL.DeleteProgram(_shader.Handle);

            base.OnUnload();
        }
    }
}